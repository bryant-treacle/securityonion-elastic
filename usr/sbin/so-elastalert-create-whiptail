#!/bin/bash -i
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Written by Bryant Treacle
# https://raw.githubusercontent.com/bryant-treacle/Elastalert-Rule-Generator/master/so-elastalert-create-whiptail
# Modified by Doug Burks
#
# Purpose:  This script will allow you to create basic elastalert rules.

# Need elevated privilages to write blacklist/whitelist files to /etc/elastalert/rules directory.

if [[ $(/usr/bin/id -u) -ne 0 ]]; then
        echo "This script needs to be run as root.  Please try again using sudo."
        exit
fi

################################
#   Dialog box color scheme    #
################################

export NEWT_COLORS='
window=gray	
border=white,brightred
textbox=white
button=white,red		
'

#############################
#        Rule Name          #
#############################
rule_name_prompt()
{
raw_rulename=$(whiptail --inputbox "\n\nWhat do you want to name the rule?" 10 60 --title "Rule Name" 3>&1 1>&2 2>&3)

exitstatus=$?

    if [ $exitstatus = 0 ] ; then
# Replace spaces in user input with underscore
rulename=$(echo ${raw_rulename,,} | sed 's/ /_/g')

cat << EOF >> "$rulename.yaml"
# Elasticsearch Host
es_host: elasticsearch
es_port: 9200

# (Required)
# Rule name, must be unique
name: $raw_rulename

EOF

    else
	rm "$rulename.yaml"
	mainmenu
    fi
}

#############################
#        Index Name         #
#############################
index_name_prompt()
{

indexname=$(whiptail --inputbox "\nWhat elasticsearch index do you want to use? Below are the default Index Patterns used in Security Onion: \n    *:logstash-* \n    *:logstash-beats-* \n    *:elastalert_status*" 12 78 --title "Index Name" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

cat << EOF >> "$rulename.yaml"
# (Required)
# Index to search, wildcard supported
index: "$indexname"

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi
}


#############################
#       Alert Options       #
#############################
alert_option_prompt()
{
alertoption=$(whiptail --title "Alert Options" --radiolist \
"\nBy default, all matches will be written back to the elastalert index. \nPlease choose from the below options:" 15 100 4 \
"debug" "Will write alerts to the *:elastalert_status* index" ON \
"slack" "Send a notification to a predefined Slack channel" OFF \
"email" "Connect to an smtp server located at smtp_host, or localhost by default." OFF 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

        if [ ${alertoption,,} = "slack" ] ; then
	    slackoption=$(whiptail --inputbox "\nThe webhook URL that includes your auth data and the ID of the channel (room) you want to post to.\n\nGo to the Incoming Webhooks section in your Slack account https://XXXXX.slack.com/services/new/incoming-webhook,\nchoose the channel, click ‘Add Incoming Webhooks Integration’ and copy the resulting URL.\n\nPlease enter the webhook URL below:" 20 85 --title "Slack Alerter Option" 3>&1 1>&2 2>&3)
	    exitstatus=$?
	    if [ $exitstatus = 0 ] ; then

        cat << EOF >> "$rulename.yaml"
# (Required)
# The alert is use when a match is found
alert:
- slack

# (required,Slack specific)
# Enter the webhook URL below
slack:
 - $slackoption

EOF
	    else
	        rm "$rulename.yaml"
		mainmenu
	    fi
	elif [ ${alertoption,,} = "email" ] ; then
            emailoption=$(whiptail --inputbox "\nPlease enter the email address you want to send the alerts to.\nNote: Ensure the Master Server is configured for SMTP."  15 85 --title "Slack Alerter Option" 3>&1 1>&2 2>&3)
            exitstatus=$?

	    if [ $exitstatus = 0 ] ; then
	cat << EOF >> "$rulename.yaml"
# (Required)
# The alert is use when a match is found
alert:
- email

# (required, email specific)
# a list of email addresses to send alerts to
email:
 - $emailoption
EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
	elif [ ${alertoption,,} = "debug" ] ; then
        whiptail --title "debug Alerter Options"  --msgbox "\nUsing the default alert type of debug.\nAlerts will only be written to the *:elastalert_status* index." 10 90
	exitstatus=$?
	    if [ $exitstatus = 0 ] ; then

   cat << EOF >> "$rulename.yaml"
# (Required)
# The alert is use when a match is found
alert:
- debug

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
        fi
    else
	rm "$rulename.yaml"
	mainmenu
    fi
}

#############################
#      Filter Options       #
#############################
filter_options_prompt()
{
filteroption=$(whiptail --title "Filter Options" --radiolist \
"\nThis script will allow you to generate a BASIC filter for your rule. To reduce the number of false positives you may need to modify the filter." 15 100 4 \
"default" "Uses a wildcard search that will include all logs for the $indexname index." ON \
"term" "Allows you to match a value in a field." OFF \
"wildcard" "Allows you to use the wildcard * in the field_value." OFF 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

        if [ ${filteroption,,} = "default" ] ; then
	    whiptail --title "debug Alerter Options"  --msgbox "\nUsing default filter options that will include all logs for the $indexname index." 10 90
	    exitstatus=$?

	        if [ $exitstatus = 0 ] ; then

	    cat << EOF >> "$rulename.yaml"
#(Required)
# A list of Elasticsearch filters used for find events
# These filters are joined with AND and nested in a filtered query
# For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html
filter:

- wildcard:
    event_type: "*"

EOF
		else
		    rm "$rulename.yaml"
		    mainmenu
		fi
        elif [ ${filteroption,,} = "term" ] ; then
	    field_name=$(whiptail --inputbox "\nThis option allows you to match a specific value in a field.\nFor example field name: source_ip field value: 192.168.1.1 or choose a specific log type you want to rule to apply ie. field name: event_type field value: bro_http \n\nWhat field do you want to filter on?" 15 90 --title "Term Filter Options" 3>&1 1>&2 2>&3)
	    exitstatus=$?

                if [ $exitstatus = 1 ] ; then
		    rm "$rulename.yaml"
		    mainmenu
		else
	    	    field_value=$(whiptail  --inputbox "\nWhat is the value for the $field_name field." 8 65 --title "Term Filter Options" 3>&1 1>&2 2>&3)
			exitstatus=$?
		        if [ $exitstatus = 0 ] ; then

	    cat << EOF >> "$rulename.yaml"
#(Required)
# A list of Elasticsearch filters used for find events
# These filters are joined with AND and nested in a filtered query
# For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query$
filter:

- term:
    $field_name: "$field_value"

EOF
			else
			    rm "$rulename.yaml"
			    mainmenu
			fi
		fi
        elif [ ${filteroption,,} = "wildcard" ] ; then
	    field_name=$(whiptail  --inputbox "\nWildcard filters allow you to use the wildcard * in the field_value to match unknown characters or to include the remaining values of a field.  For example field_name: useragent and field_value: *Mozilla* or field_name: source_ip and field_value: 192.168.*\n\nWhat field do you want to search on?" 15 90 --title "Wildcard Filter Options" 3>&1 1>&2 2>&3)
	        exitstatus=$?

	        if [ $exitstatus = 1 ] ; then
		    rm "$rulename.yaml"
		    mainmenu
	        else
	    field_value=$(whiptail  --inputbox "\nWhat is the value for the $field_name field." 10 65 --title "Wildcard Filter Options" 3>&1 1>&2 2>&3)
            cat << EOF >> "$rulename.yaml"
#(Required)
# A list of Elasticsearch filters used for find events
# These filters are joined with AND and nested in a filtered query
# For more info: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html
filter:

- wildcard:
    $field_name: "$field_value"

EOF
		fi
	fi
    else
	rm "$rulename.yaml"
	mainmenu
    fi
}
#########################################################################################
############################
#     Re-alert Options     #
############################
realert_prompt()
{
if (whiptail --yesno "\nThe realert option allows you to ignore repeating alerts for a given period of time.\nWould you like to set a realert timeframe?" 15 90 --title "ReAlert Option") then

    realert_unit_of_measure=$(whiptail --title "Realert Options" --radiolist \
    "\n\nPlease choose from the options below:\n\n" 20 80 6 \
    "weeks" "Number of weeks.                 " ON \
    "days" "Number of days.                   " OFF \
    "hours" "Number of hours.                 " OFF \
    "minutes" "Number of minutes.             " OFF \
    "seconds" "Number of seconds.             " OFF 3>&1 1>&2 2>&3)
    exitstatus=$?
         if [ $exitstatus = 0 ] ; then

         realert_timeframe=$(whiptail  --inputbox "\nPlease enter the number of $realert_unit_of_measure you want to supress alerts." 10 65 --title "ReAlert Options" 3>&1 1>&2 2>&3)
         exitstatus=$?

             if [ $exitstatus = 0 ] ; then

	cat << EOF >> "$rulename.yaml"
# This option allows you to ignore repeating alerts for a period of time.
realert:
  $realert_unit_of_measure: $realert_timeframe

EOF
            else
	        rm "$rulename.yaml"
		mainmenu
 	    fi
	else
	    rm "$rulename.yaml"
	    mainmenu
	fi
fi
}
#######################
#    Final prompt     #
#######################
final_prompt()
{
current_directory=$(pwd)
if (whiptail --yesno "\nWriting rule to the following location:\n\n $current_directory/$rulename.yaml\n\nIf you would like to test this rule, a copy will be placed in the production directory </etc/elastalert/rules> and will be tested by so-elastalert-test.\n\n Testing the rule will exit so-elastalert-create. \n\nWould you like to test the $rulename now?" 20 90 --title "Rule Test") then
sudo cp "$rulename.yaml" /etc/elastalert/rules/
sudo /usr/sbin/so-elastalert-test
fi
}

###################################
# Functions for Cardinality Rules #
###################################
cardinality_rule_prompt()
{
cardinality_field=$(whiptail  --inputbox "\nThe Cardinality rule will alert when the maximum or minimum number of unique values for a given field reaches a threshold.\nThe Cardinality field is the field to count the cardianality for.\n\nWhat field do you want to be the Cardinality Field?" 15 90 --title "Cardinality Rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

cat  << EOF >> "$rulename.yaml"

# (Required)
# Type of alert.
# The Cardinality rule matches when the total number of unique values for a certain field , within a given timeframe is higher or lower than a threshold.
type: cardinality

# (Required, cardinality specific)
# Count the number of unique value for this field
cardinality_field: $cardinality_field

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi

cardinality_max_min=$(whiptail --title "Cardinality Rule Options" --radiolist \
"\nThis rule requires one of the two following options.\n\nPlease choose from the options below:\n\n" 20 115 4 \
"maximum_cardinality" "Alert on values MORE than X unique values in the cardinality field." ON \
"minimum_cardinality" "Alert on values LESS than X unique values in the cardinality field." OFF \
"finish" "Continue building the rule." OFF 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

        if [ $cardinality_max_min = "maximum_cardinality" ] ; then
            cardinality_max=$(whiptail  --inputbox "\nPlease enter the maximum cardinality value." 10 50 --title "Cardinality Rule Options" 3>&1 1>&2 2>&3)
            exitstatus=$?

	    if [ $exitstatus = 0 ] ; then

	cat << EOF >> "$rulename.yaml"
# (Required, frequency specific)
# Alert when there is more than X unique values
max_cardinality: $cardinality_max

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
	elif [ $cardinality_max_min = "minimum_cardinality" ] ; then
        cardinality_min=$(whiptail  --inputbox "\nPlease enter the minimum cardinality value." 10 50 --title "Cardinality Rule Options" 3>&1 1>&2 2>&3)
	exitstatus=$?

	    if [ $exitstatus = 0 ] ; then

        cat << EOF >> "$rulename.yaml"
# (Required, frequency specific)
# Alert when there is less than X unique values
min_cardinality: $cardinality_min

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
	fi
    else
rm "$rulename.yaml"
	mainmenu
    fi

timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
"\nThe Cardinality timeframe is defined as the number of unique values in the most recent X timeframe.\n\nPlease choose from the options below:\n\n" 20 80 6 \
"weeks" "Number of events per week.                 " ON \
"days" "Number of events per day.                   " OFF \
"hours" "Number of events per hour.                 " OFF \
"minutes" "Number of events per minute.             " OFF \
"seconds" "Number of events per second.             " OFF 3>&1 1>&2 2>&3)
exitstatus=$?
    if [ $exitstatus = 0 ] ; then

	timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
	exitstatus=$?

	    if [ $exitstatus = 0 ] ; then

    cat << EOF >> "$rulename.yaml"
# (Required, frequency specific)
# The cardinality is defined as the number of unique values for the most recent 4 hours

timeframe:
  $timeframe_units: $timeframe

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
    else
	rm "$rulename.yaml"
	mainmenu
    fi

if (whiptail --yesno "\nThe query_key groups counts by this field. For each unique value of the query_key field, cardinality will be counted separately.\n\nWould you like to set the query_key parameter?" 20 78 --title "Query Key Option") then
     query_key=$(whiptail  --inputbox "\nWhat field do you want the query_key to be?" 15 65 --title "Query Key Options" 3>&1 1>&2 2>&3)
     exitstatus=$?

     if [ $exitstatus = 0 ] ; then
        cat << EOF >> "$rulename.yaml"
# (Optional, frequency specific)
# query_key: Group cardinality counts by this field. For each unique value of the query_key field, cardinality will be counted separately.
query_key: $query_key

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi
fi


}

#################################
# Functions for Blacklist Rules #
#################################
blacklist_rule_prompt()
{
compare_key=$(whiptail  --inputbox "\nThe blacklist rule will compare the values contained in a text file against the compare_key and alert if there is a match.\n\nWhat field do you want to compare to the blacklist?" 15 65 --title "Blacklist rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

      cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# The Blacklist rule will check  a certain field against a blacklist and match if it is in the blacklist
type: blacklist

# (Required, blacklist)
# The name of the field to use to compare to the blacklist. If the field is null, those events will be ignored.
compare_key: $compare_key

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi
if (whiptail --yesno "\nThe blacklist file should be a text file with a single value per line.  Note: The file needs to be accessible by the so-elastalert container.\n\nWould you like to create the file now?" 15 78 --title "Blacklist Option") then
     file_location=$(whiptail  --inputbox "\nPlease enter the full path AND filename of the blacklist.\nThe file location must be accessable to the Elastalert Docker Container and can be saved in the /etc/elastalert/rules/ directory.\n\n Note: The filepath will be defined in the $rulename.yaml file and can be modified later." 15 65 --title "Blacklist File Location" 3>&1 1>&2 2>&3)

     counter=0

     while [ $counter -eq 0 ] ; do
     file_value=$(whiptail  --inputbox "\nPlease enter the values for the $compare_key one at a time.\n\nWhen finished type quit." 15 65 --title "Blacklist values" 3>&1 1>&2 2>&3)
 exitstatus=$?

        if [ $exitstatus = 0 ] ; then
            if [ ${file_value,,} = "quit" ] ; then
                counter=1
            else		
                 echo "$file_value" >> $file_location
                 counter=0
            fi
        else
            rm "$rulename.yaml"
            mainmenu
        fi
    done

    cat << EOF >> "$rulename.yaml"
# (Required, blacklist)
# A list of blacklisted values, and/or a list of paths to flat files which contain the blacklisted values
blacklist:
    - "!file $file_location"

EOF

else 
    file_location=$(whiptail  --inputbox "\nPlease enter the full path AND filename of the blacklist." 15 65 --title "Blacklist File Location" 3>&1 1>&2 2>&3)
    exitstatus=$?

        if [ $exitstatus = 0 ] ; then

            cat << EOF >> "$rulename.yaml"
# (Required, blacklist)
# A list of blacklisted values, and/or a list of paths to flat files which contain the blacklisted values
blacklist:
    - "!file $file_location"

EOF
	else
	    rm "$rulename.yaml"
	    mainmenu
	fi
fi
}

#################################
# Functions for Whitelist Rules #
#################################
whitelist_rule_prompt()
{
compare_key=$(whiptail  --inputbox "\nThe whitelist rule will compare the values contained in a text file against the compare_key and alert if there is NOT a match.\n\nWhat field do you want to compare to the whitelist?" 15 65 --title "Whitelist rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then

      cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# The Whitelist rule will check a certain field against a whitelist and match if it is not in the whitelist
type: whitelist

# (Required, whitelist)
# The name of the field to use to compare to the whitelist. If the field is null, those events will be ignored.
compare_key: $compare_key

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi
if (whiptail --yesno "\nThe whitelist file should be a text file with a single value per line.  Note: The file needs to be accessible by the so-elastalert container.\n\nWould you like to create the file now?" 10 78 --title "Whitelist Rule Option") then 
     file_location=$(whiptail  --inputbox "\nPlease enter the full path AND filename of the whitelist.\nNote: The file path will be placed in the $rulename.yaml file." 10 65 --title "Whitelist File Location" 3>&1 1>&2 2>&3)
     counter=0
     while [ $counter -eq 0 ] ; do
     file_value=$(whiptail  --inputbox "\nPlease enter the values for the $compare_key one at a time.\n\nWhen finished type quit." 15 65 --title "Whitelist values" 3>&1 1>&2 2>&3)
          if [ ${file_value,,} = "quit" ] ; then
                 counter=1
          else
                 echo $file_value >> $file_location
                 counter=0
          fi
    done

    cat << EOF >> "$rulename.yaml"
# (Required, whitelist)
# A list of whitelisted values, and/or a list of paths to flat files which contain the whitelisted values
whitelist:
    - "!file $file_location"

EOF

else
    file_location=$(whiptail  --inputbox "\nPlease enter the full path AND filename of the whitelist." 15 65 --title "Whitelist File Location" 3>&1 1>&2 2>&3)
    exitstatus=$?

    if [ $exitstatus = 0 ] ; then

            cat << EOF >> "$rulename.yaml"
# (Required, whitelist)
# A list of whitelisted values, and/or a list of paths to flat files which contain the whitelisted values
whitelist:
    - "!file $file_location"

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi 
fi

if (whiptail --yesno "\nWould you like to ignore null field values?" 10 50 --title "Whitelist Additional Options") then

cat << EOF >> "$rulename.yaml"
# (Required, whitelist)
# ignore_null: If true, events without a compare_key field will not match.
ignore_null: true

EOF

else

cat <<EOF>> "$rulename.yaml"

# (Required, whitelist)
# ignore_null: If true, events without a compare_key field will not match.
ignore_null: false

EOF
fi
}

###################################
#  Functions for Frequency Rules  #
###################################
frequency_rule_prompt()
{
num_events=$(whiptail  --inputbox "\nThe Frequency rule matches when there are at least a certain number of events in a given timeframe.\n\nEnter the number of events you want to alert on:" 10 85 --title "Frequency Rule" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then
    timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
        "\nThe Frequency timeframe is defined as the number of matches in the most recent X timeframe.\n\nPlease choose from the options below:\n\n" 20 80 6 \
        "weeks" "Number of events per week.                 " ON \
        "days" "Number of events per day.                   " OFF \
        "hours" "Number of events per hour.                 " OFF \
        "minutes" "Number of events per minute.             " OFF \
        "seconds" "Number of events per second.             " OFF 3>&1 1>&2 2>&3)
        exitstatus=$?
	    if [ $exitstatus = 0 ] ; then

	        timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
		exitstatus=$?

		    if [ $exitstatus = 0 ] ; then

cat << EOF >> "$rulename.yaml"

# (Required)
# Type of alert.
# the frequency rule type alerts when num_events events occur with timeframe time
type: frequency

# (Required, frequency specific)
# Alert when this many documents matching the query occur within a timeframe
num_events: $num_events

# (Required, frequency specific)
# num_events must occur within this amount of time to trigger an alert
timeframe:
  $timeframe_units: $timeframe

EOF
		    else
			rm "$rulename.yaml"
			mainmenu
		    fi
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi
    else
	rm "$rulename.yaml"
	mainmenu
    fi

if (whiptail --yesno "\nThe frequency rule has the following additional options:\n -  use_count_query: \n -  use_terms_query: \n\n Would you like to set the optional settings?" 10 55 --title "Frequency Rule Additional Options") then
    frequency_query_type=$(whiptail --title "Frequency Rule Options" --radiolist \
    "Please choose from the options below:" 15 100 4 \
    "use_count_query" "If true, ElastALert will poll Elasticsearch using the count api." ON \
    "use_terms_query" "If true, ElastAlert will make an aggregation query against Elasticsearch." OFF  3>&1 1>&2 2>&3)
    exitstatus=$?

    if [ $exitstatus = 0 ] ; then

	if [ $frequency_query_type = "use_count_query" ] ; then
            cat << EOF >> "$rulename.yaml"

# Only count number of records, instead of bringing all data back
use_count_query: true
doc_type: 'doc'

EOF
	elif [ $frequency_query_type = "use_terms_query" ] ; then
	    query_key=$(whiptail  --inputbox "\nPlease enter the query_key." 15 65 --title "Frequency Rule Additional Options" 3>&1 1>&2 2>&3)
	    exitstatus=$?
		
	    if [ $exitstatus = 0 ] ; then
                term_size=$(whiptail --inputbox "\nThe term_size is the maximum number of unique terms that will be returned.\n\nPlease enter the term_size, default is 50." 15 65 --title "Frequency Rule Additional Options" 3>&1 1>&2 2>&3)
		exitstatus=$?
 
		    if [ $exitstatus = 0 ] ; then

            cat << EOF >> "$rulename.yaml"
# Only count number of records, instead of bringing all data back
use_terms_query: true
doc_type: 'doc'

# Query_key count of documents will be stored independently for each value of query_key
query_key: $query_key

# Term_size is the maximum number of terms returned per query.  Default is 50.
terms_size: $term_size

EOF
		    else
		        rm "$rulename.yaml"
			mainmenu
		    fi

	    else
	        rm "$rulename.yaml"
		mainmenu
	    fi
        fi
    
    else
        rm "$rulename.yaml"
	mainmenu
    fi

else
    rm "$rulename.yaml"
    mainmenu
fi
}

################################
#  Functions for Change Rules  #
################################
change_rule_prompt()
{
compare_key=$(whiptail  --inputbox "\nThe change rule will monitor a certain field and match if a value in that field changes.\nThe field must change with respect to the last event with the same query_key.\n\nWhat field do you want to monitor for changes?" 15 75 --title "Change Rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then
	query_key=$(whiptail  --inputbox "\nThe query_key parameter names the field that must be present in all of the events that are checked.\n\nPlease enter the query_key." 15 75 --title "Change Rule Options" 3>&1 1>&2 2>&3)
        exitstatus=$?

        if [ $exitstatus = 0 ] ; then
	    timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
            "\nThe change rule timeframe is the maximum time between changes. After this time period, ElastAlert will forget the old value of the compare_key field.\n\nPlease choose from the options below:\n\n" 20 80 6 \
            "weeks" "Number of weeks between changes.                 " ON \
            "days" "Number of days between changes.                   " OFF \
            "hours" "Number of hours between changes.                 " OFF \
            "minutes" "Number of minutes between changes.             " OFF \
            "seconds" "Number of seconds between changes.             " OFF 3>&1 1>&2 2>&3)
            exitstatus=$?

            if [ $exitstatus = 0 ] ; then
                timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
                exitstatus=$?

                if [ $exitstatus = 0 ] ; then

    cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# This rule will monitor a certain field and match if that field changes.
type: change

# (Required, change specific)
# The field to look for changes in
compare_key: $compare_key

# (Required, change specific)
# Ignore documents without the compare_key (source_ip) field
ignore_null: true

# (Required, change specific)
# The change must occur in two documents with the same query_key
query_key: $query_key

# (Required, change specific)
# The value of compare_key must change in two events that are less than timeframe apart to t$
timeframe:
  $timeframe_units: $timeframe

EOF
		else
		    rm "$rulename.yaml"
		    mainmenu
		fi

	    else
		rm "$rulename.yaml"
	        mainmenu
	    fi
    
        else
	    rm "$rulename.yaml"
	    mainmenu
	fi

    else
	rm "$rulename.yaml"
	mainmenu
    fi
	
}

################################
#  Functions for Spike Rules   #
################################
spike_rule_prompt()
{
spike_height=$(whiptail  --inputbox "\nThe spike rule matches when the volume of events during a given time period is spike_height times larger or smaller than during the previous time period. Note: This value is a multiple!!  2 = 2x as many; 5 = 5x as many\n\nWhat do you want the spike_type parameter to be?" 15 90 --title "Spike Rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then
    spike_type=$(whiptail --title "Spike Rule Options" --radiolist \
        "\nPlease choose from the options below:    " 15 65 5 \
        "up" "more than previous timeframe.         " ON \
        "down" "less than previous timeframe.       " OFF \
        "both" "up and down.                        " OFF 3>&1 1>&2 2>&3)
        exitstatus=$?

    	    if [ $exitstatus = 0 ] ; then
            timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
            "\nThe spike rule will average out the rate of events over this time period.\n\nPlease choose from the options below:\n\n" 20 80 6 \
            "weeks" "Number of weeks to average.                 " ON \
            "days" "Number of days to average.                   " OFF \
            "hours" "Number of hours to average.                 " OFF \
            "minutes" "Number of minutes to average.             " OFF \
            "seconds" "Number of seconds to average.             " OFF 3>&1 1>&2 2>&3)
            exitstatus=$?

                if [ $exitstatus = 0 ] ; then
		    timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
		    exitstatus=$?

            	    if [ $exitstatus = 0 ] ; then
    cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# This rule matches when the volume of events during a given time period is spike_height times larger or smaller than during the previous time period.
type: spike

# (Required, spike specific)
# The ratio of number of events in the last timeframe to the previous timeframe.
spike_height: $spike_height

# (Required, spike specific)
# The spike being up, down or both
spike_type: $spike_type

# (Required, spike specific)
# The value of average out the rate of events over this time period.
timeframe:
  $timeframe_units: $timeframe

EOF
	            else
		        rm "$rulename.yaml"
			mainmenu
	            fi

		else
		    rm "$rulename.yaml"
		    mainmenu
		fi

	    else
		rm "$rulename.yaml"
	        mainmenu
	    fi

	else
	    rm "$rulename.yaml"
	    mainmenu
	fi

if (whiptail --yesno "The spike rule has the following optional parameters:\n
 - field_value: When set, uses the value of the field in the document and not the number of matching documents.\n 
 - threshold_ref: The minimum number of events that must exist in the reference window for an alert to trigger.\n
 - threshold_cur: The minimum number of events that must exist in the current window for an alert to trigger.\n\n
Would you like to choose these options?" 25 78 --title "Spike Rule Additional Options") then
    counter=0
    while [ $counter -eq 0 ] ; do
	counter=$(( $counter + 1 ))
    	spike_additional_options=$(whiptail --title "Spike Rule Additional Options" --radiolist \
	"Please choose from the options below:" 15 130 6 \
	"field_value" "The value of the field in the document and not the number of matching documents." ON \
	"threshold_ref" "The min number of events that must exist in the reference window for an alert to trigger." OFF \
	"threshold_cur" "The minimum number of events that must exist in the current window for an alert to trigger." OFF \
	"finish" "Continue building the rule" OFF 3>&1 1>&2 2>&3)
        if [ $spike_additional_options = "field_value" ] ; then
	    field_value_field=$(whiptail  --inputbox "What field would you like to use?" 15 65 --title "Spike Rule Additional Options" 3>&1 1>&2 2>&3)
		cat << EOF >> "$rulename.yaml"
#(Optional, spike specific)
# field_value: When set, uses the value of the field in the document and not the number of matching documents.
field_value: $spike_options_select

EOF
# reset the counter for the while loop
        counter=0
	elif [ $spike_additional_options = "threshold_ref" ] ; then 
            threshold_ref_field=$(whiptail  --inputbox "What would you like the threshold_ref to be?" 15 65 --title "Spike Rule Additional Options" 3>&1 1>&2 2>&3)
                    cat << EOF >> "$rulename.yaml"
#(Optional, spike specific)
# The minimum number of events that must exist in the reference window for an alert to trigger.
threshold_ref: $threshold_ref_field

EOF
#Reset the counter for the while loop
        counter=0
    elif [ $spike_additional_options = "threshold_ref" ] ; then
        threshold_ref_field=$(whiptail  --inputbox "What would you like the threshold_ref to be?" 15 65 --title "Spike Rule Additional Options" 3>&1 1>&2 2>&3)
            cat << EOF >> "$rulename.yaml"
#(Optional, spike specific)
# The minimum number of events that must exist in the reference window for an alert to trigger.
threshold_ref: $threshold_ref_field

EOF
#Reset the counter for the while loop
        counter=0
    elif [ $spike_additional_options = "threshold_cur" ] ; then
	threshold_cur_field=$(whiptail  --inputbox "What would you like the threshold_cur to be?" 15 65 --title "Spike Rule Additional Options" 3>&1 1>&2 2>&3)
#(Optional, spike specific
# The minimum number of events that must exist in the current window for an alert to trigger.
threshold_cur: $threshold_cur_field

EOF
#Reset the counter for the while loop
        counter=0
    else 
	counter=1
    fi
  done
fi
}

###################################
#  Functions for new term Rules   #
###################################
new_term_rule_prompt()
{
new_term_field=$(whiptail --inputbox "\nThis rule matches when a new value appears in a field that has never been seen before. When ElastAlert starts, it will use an aggregation query to gather all known terms for a field.\n\nWhat field do you want to monitor for new terms?" 15 90 --title "New Term Rule" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then
    cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# This rule matches when a new value appears in a field that has never been seen before.
type: new_term

# (Required, new_term specific)
# Monitor the field ip_address
fields:
 - "$new_term_field"

EOF
    else
	rm "$rulename.yaml"
	mainmenu
    fi
if (whiptail --yesno "\nThe new term rule has the following optional parameters:\n
 - terms_window_size: The amount of time used for the initial query to find existing terms. No term that has occurred within this time frame will trigger an alert. The default is 30 days.\n
 - window_step_size: When querying for existing terms, split up the time range into steps of this size. This is usefull when covering large timeframes\n
 - alert_on_missing_field: Whether or not to alert when a field is missing from a document. The default is false.\n\n
Would you like to set any of these options?" 20 90 --title "New Term Rule Additional Options") then 
    counter=0
    while [ $counter -eq 0 ] ; do
        counter=$(( $counter + 1 ))
        new_term_additional_options=$(whiptail --title "Spike Rule Additional Options" --radiolist \
        "\nPlease choose from the options below:" 15 130 6 \
        "terms_window_size" "The time used for the initial query to find existing terms." ON \
        "window_step_size" "Split up the time range into steps of this size." OFF \
        "alert_on_missing_field" "Whether or not to alert when a field is missing from a document" OFF \
        "finish" "Continue building the rule" OFF 3>&1 1>&2 2>&3)
	exitstatus=$?

        if [ $exitstatus = 0 ] ; then
            if [ $new_term_additional_options = "terms_window_size" ] ; then
	        exitstatus=$?

	        timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
            	"\nThe new term timeframe is the amount of time used for the initial query to find existing terms. Default is 30 Days\n\nPlease choose from the options below:\n\n" 20 80 6 \
            	"weeks" "Number of weeks for initial query.          " ON \
            	"days" "Number of days for intial query.             " OFF \
            	"hours" "Number of hours for initial query.          " OFF \
            	"minutes" "Number of minutes for initial query.      " OFF \
            	"seconds" "Number of seconds for initial query.      " OFF 3>&1 1>&2 2>&3)
            	exitstatus=$?

                if [ $exitstatus = 0 ] ; then
                    timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
                    exitstatus=$?

		    if [ $exitstatus = 0 ] ; then

                cat << EOF >> "$rulename.yaml"
# (Optional, new_term specific)
# This means that we will query 90 days worth of data when ElastAlert starts to find which values of ip_address already exist
# If they existed in the last 90 days, no alerts will be triggered for them when they appear
terms_window_size:
  $timeframe_units: $timeframe

EOF
		    else
		        rm "$rulename.yaml"
			mainmenu
		    fi
		    
		else
		    rm "$rulename.yaml"
		    mainmenu
		fi
#reset counter for while loop
        counter=0
    	    elif [ $new_term_additional_options = "window_step_size" ] ; then
            exitstatus=$?

                if [ $exitstatus = 0 ] ; then
    	        timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
                "\nThe new term the window_step_size split up the time range into steps of this size.\n\nPlease choose from the options below:\n\n" 20 90 6 \
                "weeks" "Number of weeks.          " ON \
                "days" "Number of days.            " OFF \
                "hours" "Number of hours.          " OFF \
                "minutes" "Number of minutes.      " OFF \
                "seconds" "Number of seconds.      " OFF 3>&1 1>&2 2>&3)
                exitstatus=$?

                    if [ $exitstatus = 0 ] ; then
                        timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
                        exitstatus=$?

                        if [ $exitstatus = 0 ] ; then
            cat << EOF >> "$rulename.yaml"

# (Optional, new_term specific)
# This means that we will query 90 days worth of data when ElastAlert starts to find which values of ip_address alr$
# If they existed in the last 90 days, no alerts will be triggered for them when they appear
window_step_size:
  $timeframe_units: $timeframe

EOF
		        else
			    rm "$rulename.yaml"
			    mainmenu
		        fi

		    else
		        rm "$rulename.yaml"
	     	        mainmenu
		    fi

	        else
		    rm "$rulename.yaml"
		    mainmenu
	        fi
#reset counter for while loop
	counter=0
	elif [ $new_term_additional_options = "alert_on_missing_field" ] ; then
	    alert_on_missing_field_option=$(whiptail  --inputbox "\nPlease enter either true or false for the alert_on_missing_field." 15 65 --title "Missing Field Options" 3>&1 1>&2 2>&3)
            exitstatus=$?
 
            if [ $exitstatus = 0 ] ; then
	cat << EOF >> "$rulename.yaml"
# (Optional, new_term specific)
# Whether or not to alert when a field is missing from a document. The default is false.
alert_on_missing_field: $alert_on_missing_field_option

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi

	else
	    counter=1
	fi
    
    else
	rm "$rulename.yaml"
	mainmenu
    fi
   done
fi
}


###################################
#  Functions for Flat line Rules  #
###################################
flatline_rule_prompt()
{
threshold=$(whiptail  --inputbox "\nThe flatline rule matches when the total number of events is under a given threshold for a certain peroid of time.\n\nPlease enter the minimum threshold of events." 15 65 --title "Flatline Rule Options" 3>&1 1>&2 2>&3)
exitstatus=$?

    if [ $exitstatus = 0 ] ; then
    timeframe_units=$(whiptail --title "Timefame Options" --radiolist \
    "\nThe flat rule timeframe is the period that must contain less than threshold events.\n\nPlease choose from the options below:\n\n" 20 90 6 \
    "weeks" "Number of weeks.          " ON \
    "days" "Number of days.            " OFF \
    "hours" "Number of hours.          " OFF \
    "minutes" "Number of minutes.      " OFF \
    "seconds" "Number of seconds.      " OFF 3>&1 1>&2 2>&3)
    exitstatus=$?
	if [ $exitstatus = 0 ] ; then
        timeframe=$(whiptail  --inputbox "\nPlease enter the number of $timeframe_units you want to use." 15 65 --title "Timeframe Options" 3>&1 1>&2 2>&3)
            exitstatus=$?

            if [ $exitstatus = 0 ] ; then

    cat << EOF >> "$rulename.yaml"
# (Required)
# Type of alert.
# flatline: This rule matches when the total number of events is under a given threshold for a time period.
type: flatline

# (Required, flatline specific)
# threshold: The minimum number of events for an alert not to be triggered.
threshold: $threshold

# (Required, flatline specific)
# The value of average out the rate of events over this time period.
timeframe:
  $timeframe_units: $timeframe

EOF
	    else
		rm "$rulename.yaml"
		mainmenu
	    fi

	else
	    rm "$rulename.yaml"
	    mainmenu
	fi

    else
	rm "$rulename.yaml"
	mainmenu
    fi
if (whiptail --yesno "\nThe flatline rule has the following optional parameters:\n  - use_count_query:If true, ElastAlert will poll Elasticsearch using the count api, and not download all of the matching documents.\n - use_terms_query: If true, ElastAlert will make an aggregation query against Elasticsearch to get counts of documents matching each unique value of query_key.\n - terms_size: When used with use_terms_query, this is the maximum number of terms returned per query. Default is 50.\n - query_key: With flatline rule, query_key means that an alert will be triggered if any value of query_key has been seen at least once and then falls below the threshold.\n  - forget_keys: Only valid when used with query_key. If this is set to true, ElastAlert will “forget” about the query_key value that triggers an alert\n\nWould you like to set any of these parameters?" 25 90 --title "Flat line rule Options") then
    counter=0
    while [ $counter -eq 0 ] ; do
        counter=$(( $counter + 1 ))
        flatline_option_select=$(whiptail --title "Flatline Rule Additional Options" --radiolist \
        "\nPlease choose from the options below:" 25 110 6 \
        "use_count_query" "If true, ElastAlert will poll  and not download all of the documents." ON \
        "use_terms_query" "If true, ElastAlert will get counts of each unique value of query_key." OFF \
        "term_size" "The maximum number of terms returned per query. Default is 50." OFF \
        "finish" "Continue building the rule" OFF 3>&1 1>&2 2>&3)
	    if [ $flatline_option_select = "use_count_query" ] ; then
	    use_count_query=$(whiptail  --inputbox "\nPlease enter true or false for the use_count_query field." 15 65 --title "Flatline Additional Options" 3>&1 1>&2 2>&3)
	    exitstatus=$?

                if [ $exitstatus = 0 ] ; then
	cat  << EOF >> "$rulename.yaml"

# (Optional, flatline specific)
# use_count_query: If true, ElastAlert will poll Elasticsearch using the count api, and not download all of the matching documents.
use_count_query: $use_count_query
doc_type: 'doc'

EOF
	        else
		    rm "$rulename.yaml"
		    mainmenu
		fi
#Reset counter for while loop
                counter=0

	    elif [ $flatline_option_select = "use_terms_query" ] ; then
		use_terms_query=$(whiptail  --inputbox "\nPlease enter true or false for the use_terms_query." 15 65 --title "Flatline Additional Options" 3>&1 1>&2 2>&3)
		exitstatus=$?

            	if [ $exitstatus = 0 ] ; then
	            query_key=$(whiptail  --inputbox "\nPlease enter the query_key field." 15 65 --title "Flatline Additional Options" 3>&1 1>&2 2>&3)
	 	    exitstatus=$?

            	    if [ $exitstatus = 0 ] ; then
   	 	    forget_keys=$(whiptail  --inputbox "\nPlease enter true of false for the forget_keys field." 15 65 --title "Flatline Additional Options" 3>&1 1>&2 2>&3)
  		    exitstatus=$?

                        if [ $exitstatus = 0 ] ; then
	 cat << EOF >> "$rulename.yaml"

# (Optional, flatline specific)
# Use_terms_query: If true, ElastAlert will make an aggregation query against Elasticsearch to get counts of documents matching each unique value of query_key."
use_terms_query: $use_terms_query

# (Optional, flatline specific)
# Query_key means that an alert will be triggered if any value of query_key has been seen at least once and then falls below the threshold."
query_key: $query_key

# (Optional, flatline specific)
# If this is set to true, ElastAlert will “forget” about the query_key value that triggers an alert, therefore preventing any more alerts for it until it’s seen again.
forget_keys: $forget_keys

EOF
			else
			    rm "$rulename.yaml"
			    mainmenu
			fi

		    else
			rm "$rulename.yaml"
			mainmenu
		    fi

		else
		    rm "$rulename.yaml"
	    	    mainmenu
		fi
#Reset counters for while loop
                counter=0

	    elif [ $flatline_option_select = "term_size" ] ; then
		term_sizee=$(whiptail  --inputbox "\nPlease enter the maximum number of terms returned per query,  Default is 50" 15 65 --title "Flatline Additional Options" 3>&1 1>&2 2>&3)
		exitstatus=$?

                if [ $exitstatus = 0 ] ; then

	cat << EOF >> "$rulename.yaml"

# (Optional, flatline specific)
# When used with use_terms_query, this is the maximum number of terms returned per query. Default is 50.
terms_size: $terms_size

EOF
		else
		    rm "$rulename.yaml"
		    mainmenu
		fi
#Reset counters for while loop
                counter=0

	    elif [ $flatline_option_select = "finish" ] ; then
                counter=1
            fi
        done
fi
}

######################
# Main Menu Function #
######################
mainmenu() 
{
    rule_choice=$(whiptail --title "Main Menu" --fb --menu "Please choose the rule you want to create." 20 60 10 \
        "1" "Cardinality rules      " \
        "2" "Blacklist rules     " \
        "3" "Whitelist rules     " \
	"4" "Frequency rules     " \
	"5" "Change rules     " \
	"6" "Spike rules     " \
	"7" "New Term rules     " \
	"8" "Flatline rules     " 3>&1 1>&2 2>&3)

exitstatus=$?
if [ $exitstatus = 0 ] ; then
    case $rule_choice in
        1)
	rule_name_prompt
	index_name_prompt
	cardinality_rule_prompt
	filter_options_prompt
	realert_prompt
	alert_option_prompt
	final_prompt
	;;
        2)
 	rule_name_prompt
        index_name_prompt
	blacklist_rule_prompt
	filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
        ;;
        3)
	rule_name_prompt
        index_name_prompt
        whitelist_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
        ;;
	4)  
	rule_name_prompt
        index_name_prompt
        frequency_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
	;; 
	5)
        rule_name_prompt
        index_name_prompt
        change_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
        ;;
	6)
        rule_name_prompt
        index_name_prompt
        spike_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
        ;;
	7)
        rule_name_prompt
        index_name_prompt
        new_term_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
        ;;
	8)
        rule_name_prompt
        index_name_prompt
        flatline_rule_prompt
        filter_options_prompt
        realert_prompt
        alert_option_prompt
        final_prompt
	;;
   esac
else
    exit
fi
}

#####################
# Launch the Script #
#####################

mainmenu
